---
layout: post
title: Новый взгляд на Java и IDE
---

Я уже давно пишу на языках с динамической типизацией: первым (после изначального C/C++) был php, потом perl, потом python, сейчас ruby.
И всегда думал, что язык программирования первичен.
И до недавнего момента с непониманием косился на яву, мол, зачем явно указывать типы? Это же лишняя работа для программиста, а современная динамика прекрасно в рантайме эти типы вычисляет и использует.
Более того, мне нравилась концепция утиной типизации, когда ты можешь передать любой объект, который должен просто отвечать на нужные методы, и при этом совершенно необязательно он должен быть какого-то предопределенного типа.
Код на динамике выглядит короче и яснее километровых листингов с указаниями типов и прочей, как мне казалось, нужной только компилятору для оптимизации, информации.
А если вы уж собрались оптимизировать, то зачем прослойка из виртмашины? Пишите сразу на C/C++, там статическая типизация уж точно поможет оптимизации.
Шучу.

Всё это было до недавнего времени, когда я распробовал замечательную IDE для явы от JetBrains: IntelliJ IDEA.
После написания с её помощью парочки не особо крупных «игрушечных» проектов начинаешь понимать, что программирование действительно сложных вещей это не столько набор кода, сколько построение архитектуры.
А архитектура строится путем непрерывного рефакторинга вашей программы.
И в «Идее» возможности рефакторинга настолько велики, что по большому счету программирование состоит из ввода новых идентификаторов, выбора нужных методов из меню автодополнения, и нажатия хоткеев функций рефакторинга.
Всё это возможно только потому, что среда разработки для статического языка знает, какая у вас объектная модель в программе, и может автоматизированно с ней работать.
А в динамике объектная модель только в голове программиста, а компьютеру известна только во время выполнения, и то она может меняться практически неограниченно, поэтому автоматизированный рефакторинг сильно затруднен.
В то время, как с применением совеременных инструментов программист на статическом языке одним нажатием выделяет и переносит методы, разделяет и объединяет классы, программист на динамике вручную в очередной раз правит сигнатуры методов, и сам ищет и изменяет места, где использовался только что отрефакторенный код.
Да, писать на динамике короче, но со статикой очень часто пишет за тебя среда разработки.
Что же касается утиной типизации, то она полностью заменяется механизмом интерфейсов в яве.


И в итоге меняется отношение к программному коду в целом.
Его начинаешь рассматривать не как текст, который ты правишь сам, и поэтому чем меньше текста, тем легче его править, а как база данных исполняемых объектов, в котором информация о типах является метаданными.
И с такой базой данных ты работаешь не напрямую, а через посредника — IDE, которая сама менеджит эти метаданные, и на их основе предоставляет функции, которые для динамических языков просто невозможны.
И эта база данных сама поддерживает целостность также, как и реляционные БД поддерживают связность таблиц первичными ключами и ограничениями.

Отсюда вытекает и следующий возможный вариант развития IDE, в которой редактируется напрямую AST-дерево программы в её структурированном представлении, а язык, код в виде последовательности символов — вторичен и генерируется из синтаксического дерева, а то и вовсе его нет как такового, а синтаксическое дерево сериализуется в какой-нибудь стандартный формат и напрямую отдается компилятору, освобождая его от одной довольно затратной в плане ресурсов стадии компиляции — разбора текста на токены.

А еще такая среда разработки может дать большой прирост продуктивности программиста, если использовать современные способы взаимодействия с компьютером: touch-интерфейсы и, возможно, голосовой ввод вместо «классических» мыши и клавиатуры.
Представь, сидишь ты с айпадом, и пальцем взял и перетащил два предложения из метода в класс, произнес новый идентификатор, и вот у тебя рефакторинг «Extract method».
Перетащил идентификатор на место его использования, получилось «Inline».
Или двумя пальцами «сжал» часть предложения, и получилось «Introduce Variable».
Или «смахнул» метод вниз, он перешел в подкласс, а если вверх — то в суперкласс.
Сделал круговой жест вокруг класса — сгенерировался класс-обертка.
Это проще, удобнее, понятнее и естественнее, чем запоминать распальцовки (часто из 3-4 клавиш) хоткеев существующих IDE, и тем более проще, чем вручную менять сигнатуры и вырезать-копировать код в динамике.
Можно много нафантазировать, но эти фантазии вполне реально воплотить в действительность.

А вы бы хотели такую IDE?
